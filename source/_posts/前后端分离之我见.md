title: 实践中的前后端分离
date: 2017-05-11 23:07:48
tags: 开发
---
相信前后端分离这个词，很多人都已经听说，并有一些自己的观点，但可能有一部分人的观点仍有稍许偏差：我们老早就分离了，全AJAX，使用Angular或者什么什么就可以了。

# 什么是前后端分离
我们来聊聊什么是前后端分离。

先来看一张WEB系统前后端架构模型图。

![WEB系统前后端架构模型](https://github.com/genify/ita1024/raw/master/res/pic-1.png)

从图中可以清晰的看到，前后端的界限是按照浏览器和服务器的划分。那么我们经常会发现一些问题：
1. 模板层归属前端还是后端？
2. 模板强依赖于后端渲染，前端开发需要等待后端开发吗？

通常情况，模板层归属于前端，因为让后端人员来接触他们不擅长的样式和 js 交互是很蛋疼的事情。

那么，作为前端开发的我们在实际的开发场景中又会遇到以下问题：

1. 环境： 进行本地开发，需要起后端环境，如 Tomcat、PHP，影响开发效率
2. 流程：前端开发先开发 html，再将 html 改写成指定的模板语法（俗称套模板），影响开发效率
3. 接口：
    * 接口定义一般使用 word 文档，前端开发时不好理解接口字段，影响开发效率
    * 接口变更需要重新编写文档，并重新发送，影响开发效率
    * 文档散落，影响接口维护
4. 联调：
    * 联调过程变得很复杂，尤其是没有做热部署的Java工程，改视图还需要重启Tomcat，影响前端联调效率 
5. 效益：
    * 前端开发更关注用户体验，而后端只希望关注数据可靠，为实现如响应式、ssr之类的一些交互，前端需要掌控一定的请求响应能力
    * 如果前后端对接的方式转变成为服务调用的方式，对于提升开发效率、更清晰的职责与接口复用都是有好处的

出现影响开发效率的事情，就说明现有的模式存在问题，显然问题的解题思路需要我们重新思考“前后端”的定义。此时，前后端分离的概念便应运而生，目的是将前后端开发人员的合作方式调节到大家都尽可能舒适的姿势。

# 有哪些实现方案
## SPA
![SPA](https://github.com/genify/ita1024/raw/master/res/pic-7s.gif)
全称 Single Page Application，使用前端路由的方式代替后端的 controller，并使用前端模板代替后端的模板引擎渲染，使用 restful api 实现与后端的数据交互。

在这个方案中，前后端的交互被转换成了纯粹的 http 方式的 JSON 串交互。

### SPA 的优势：
1. 环境：前端开发者不需要本地起后端环境
2. 流程：独立的前端开发方式，更低的 Mock 要求，起个静态 server 便能提供 mock 数据
3. 联调：清晰的对接方式，JSON 对于前后端来说都是比较纯粹的
4. 效益：对于用户来说，用户体验的提升

### SPA 的劣势
1. SEO 弱
2. 前端需要处理一些本不需要在这一层处理的事情，如权限控制交给前端控制

综上，SPA 是一个可以解决前后端分离的有效方案，对于无 SEO 要求的项目大可以尝试。

## 开发阶段的分离 -- 模拟数据 && 代理
故名思意，开发阶段的前后端分离，需要依赖工具实现，如笔者所开发的 Mock Server -- [Foxman](https://github.com/kaola-fed/foxman)。  

我们将一个项目开发重点划分为两个阶段：开发，联调。正好可以和我们 “模拟数据”、“代理” 两种方式契合。  
让我们通过实际的场景来表述这种前后端的合作方式。

### 接口定义
我们接到一个需求，实现某个功能。在我们理清楚具体的功能之后，应该与后端定义接口，包括：
1. 同步接口 与 返回的 Model 格式
2. 异步接口 与 返回的 json 格式

### 开发阶段
为了不等待后端开发完成再进行我们的开发工作，前端开发者需要使用 Mock 这种方式来提供页面。  

![](https://github.com/genify/ita1024/raw/master/res/pic-as.gif)

比如使用笔者的 Foxman，你只需在本地按特定格式存放一个json文件，即可被 Mock Server 取为页面或接口的 Model。  
而在开发过程中，遵循 html -> css -> js 的顺序开发，Foxman 拥有一个更智能的 live reload（更改css 之会 reload css） ，这一步会很顺畅。

### 联调
在我们开发完页面后，我们期望的是与后端进行联合调试，已验证功能开发是否存在缺陷，即联调阶段。
![](https://github.com/genify/ita1024/raw/master/res/pic-8s.gif)

在这步骤中，我们只需要更换 数据的来源，将原本响应 Mock 文件的请求，转发到真实的目标服务器，当然在联调阶段会是 开发主机 或者 测试机。

此处代理和转发，笔者已抽象成了的另外一个库 [koa-api-forward](https://github.com/imhype/koa-api-forward)，欢迎交流和使用。

### 开发阶段的分离优势
1. 环境：
    * 前端开发者不需要本地起后端环境
2. 流程：
    * 独立的前端开发方式，Mock 与 Proxy 结合，流程清晰
    * 前端可以在本地调试 view 层，大幅度提升前端的联调效率
3. 联调：
    * 清晰的对接方式，JSON 实现前后端来说都是比较纯粹的
4. 效益：
    * 方便开发的同时，保持线上系统的无侵入


### 开发阶段的分离劣势
1. Mock 数据仍需要手动维护
2. 未真正掌握线上的接口响应，实现一些前端交互需求时仍依赖后端，或无法进行（如 ssr）


## Node.js 中间层
这个模式自然时结合了前面的 Proxy。大家都知道 Node.js Server 里面强调一个 中间件的 概念，对应到设计模式的职责链模式。即只处理自己能处理的情况，否则，继续往后传递，直到被处理。

这个方案中，Proxy 作为了 中间件体系中的最后一层，用以转发请求，而在这之前依次是 中间件的错误处理、静态资源的响应、路由拦截（routers） 等等。  

而 Node.js 拥有一定的接口控制能力，如处理 PC/Mobile 的响应式渲染，或是 Server-Side-Render 等等。


### 开发阶段的分离优势
1. 环境：
    * 前端开发者不需要本地起后端环境
2. 流程：
    * 独立的前端开发方式，Mock 与 Proxy 结合，流程清晰
    * 前端可以在本地调试 view 层，大幅度提升前端的联调效率
3. 联调：
    * 清晰的对接方式，JSON 实现前后端来说都是比较纯粹的
4. 效益：
    * 渐进式，初期可以将请求全部转发后端服务器，而后可以一点点由前端 router 响应
    * 职责分明，Node.js 层 调用 Java 的服务，并输出页面
    * 可组合性，Java 只需编写较为抽象的服务，Node.js 负责组合拼装，实现可复用率

### 开发阶段的分离劣势
* 开发阶段仍需要 Mock 支持，需要包含 Mock 的支持
* 对现有系统的渐进式改造是个漫长的过程